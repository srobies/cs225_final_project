**CS 225 Data Structures**

**Final Project Report (racheld3-slr6-mweiler3-provine2)**

For our project, we aimed to determine the betweenness centrality of airports around the world. We intended to produce a list of all airports ranked by the betweenness centrality of each, with the end goal being to find the most important airport. In the case of our project, we determined that the highest importance corresponds to the greatest betweenness centrality.

In working toward this goal, we first implemented several functions which converted the open source data sets of flight routes and airports provided on OpenFlights.org to two different data structures: an adjacency matrix and a graph. One of the most notable discoveries made in this portion of the project was that the data set did not include all of the information for every airport and route entry. Due to this, in our development, we chose to omit certain airports from our data structure if the data set did not include the necessary information about them. Prior to applying algorithms on these data structures, we wrote several test cases which were designed to test whether or not the data structures were accurately constructed. As it would take an excessive amount of time to check every airport and every route, we chose instead to include a more limited assortment of cases.

Once the accuracy of both the adjacency matrix and graph were confirmed, we moved forward with implementing several algorithms. The algorithms implemented include a depth first search (DFS) algorithm on the graph data structure, Dijkstra’s algorithm on the adjacency matrix, and a variation of the Girvan-Newman algorithm on the adjacency matrix. 

The DFS development caused the realization that there were a small number of airports that were not connected to the larger graph structure. We assume this is due to the routes dataset only being a small subset of the flight routes for these airports. Additionally, since many of the airports in airports.dat did not have routes in routes.dat, we were able to greatly reduce the size of the adjacency matrix. This reduced the sparseness of the adjacency matrix and should decrease runtime. DFS was implemented using the graph structure we created, but this reduction in the size of the dataset benefits both the adjacency matrix and the graph structure. 

The DFS implementation uses an iterator to visit each airport node. There is an additional check beyond the standard DFS implementation that ensures that even the disconnected airport nodes will be visited. 

Dijkstra’s algorithm was the second algorithm that we implemented. As many airports were disconnected from larger sections of the graph, we found it much easier to implement Dijkstra’s algorithm using the adjacency matrix. In doing so, a few vectors were created. One helped keep track of which airports had already been added while another allowed us to keep track of the number of flights on the shortest path between airports. As it would have been significantly more complicated to calculate geographical distances between airports, accounting for the curvature of the earth, we chose to classify the length of paths according to the number of flights needed to get from one airport to another. For example, if you could get from one airport to another in one flight, the shortest path between those two airports would be represented as a distance of 1. This would be true for all pairs of airports which have a flight connecting the two, regardless of how close or far apart the airports physically are. This allowed our Dijkstra’s algorithm to run more efficiently. It also allowed us to focus more on the connections between airports rather than their locations and the magnitude of the distance between them, which is something we were not concerned with in reaching the goals of our project.

During the development of the project, we realized that Girvan-Newman did not achieve the goal that we wanted. Girvan-Newman detects communities in a graph, it does not find the nodes with the highest betweenness centrality. However, we still wanted to accomplish the goal written on our proposal. So, we did not implement the edge removal and betweenness calculation. Instead, we calculated the betweenness of every node and stored them. We could then take the data and sort them in descending order of betweenness to get a ranking of airport importance. This is more inline with the goal listed in our project proposal. We did this by using our implemented Dijkstra’s to calculate the shortest paths to every airport using each airport as a source. Using this, we could calculate the betweenness of each airport by counting how many times it appeared on a shortest path. This allows us to find the airports with the largest number of shortest path flights through them, and rank the airports. One issue with our implementation is that our Dijkstra’s takes a relatively long time. So, the betweenness calculations runtime increases rather rapidly as the size of the dataset increases.

To see a full run of our program on the full dataset, view the test.txt file in our repo. This run used the Rabah Bitat airport as the source for the example of Dijkstra's. 
